/*!
 * This script generates the exports for all utility types from `src/lib/commandclass/*CC.ts`
 */

import * as fs from "fs";
import * as path from "path";
import * as prettier from "prettier";
import ts from "typescript";

// Find this project's root dir
const projectRoot = path.join(__dirname, "..");
// Define where the CC index file is located
const ccIndexFile = path.join(projectRoot, "src/lib/commandclass/index.ts");

function loadTSConfig(): { options: ts.CompilerOptions; fileNames: string[] } {
	const configFileName = ts.findConfigFile(
		"../",
		ts.sys.fileExists,
		"tsconfig.json",
	);
	if (!configFileName) throw new Error("tsconfig.json not found");

	const configFileText = ts.sys.readFile(configFileName);
	if (!configFileText) throw new Error("could not read tsconfig.json");

	const parsedCommandLine = ts.getParsedCommandLineOfConfigFile(
		configFileName,
		{},
		ts.sys as any,
	);
	if (!parsedCommandLine) throw new Error("could not parse tsconfig.json");

	return {
		options: parsedCommandLine.options,
		fileNames: parsedCommandLine.fileNames,
	};
}

// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
function findExports() {
	// Create a Program to represent the project, then pull out the
	// source file to parse its AST.

	const tsConfig = loadTSConfig();
	const program = ts.createProgram(tsConfig.fileNames, tsConfig.options);

	// Used to remember the exports we found
	const ccExports = new Map<string, { name: string; typeOnly: boolean }[]>();
	function addExport(
		filename: string,
		name: string,
		typeOnly: boolean,
	): void {
		if (!ccExports.has(filename)) ccExports.set(filename, []);
		ccExports.get(filename)!.push({ name, typeOnly });
	}

	// Scan all source files
	for (const sourceFile of program.getSourceFiles()) {
		// Only look at CC files
		if (!sourceFile.fileName.endsWith("CC.ts")) continue;
		const fileFullText = sourceFile.getFullText();
		const relativePath = path.relative(
			path.join(__dirname, ".."),
			sourceFile.fileName,
		);

		// Visit each root node to see if it has a `@apiExport` comment
		ts.forEachChild(sourceFile, (node) => {
			// Define which declaration types we need to export
			if (
				ts.isEnumDeclaration(node) ||
				ts.isTypeAliasDeclaration(node) ||
				ts.isInterfaceDeclaration(node)
			) {
				const leadingComments = ts.getLeadingCommentRanges(
					fileFullText,
					node.pos,
				);
				if (!leadingComments) return;

				for (const comment of leadingComments) {
					const commentText = fileFullText.slice(
						comment.pos,
						comment.end,
					);
					if (commentText.includes("@publicAPI")) {
						// It has, make sure we're trying to access a node that is actually exported
						if (
							!node.modifiers?.some(
								(m) => m.kind === ts.SyntaxKind.ExportKeyword,
							)
						) {
							const location = ts.getLineAndCharacterOfPosition(
								sourceFile,
								node.getStart(sourceFile, false),
							);
							throw new Error(
								`${relativePath}:${location.line} Found @publicAPI comment, but the node ${node.name.text} is not exported!`,
							);
						}
						addExport(
							sourceFile.fileName,
							node.name.text,
							ts.isTypeAliasDeclaration(node) ||
								ts.isInterfaceDeclaration(node),
						);
					}
				}
			}
		});
	}
	return ccExports;
}

let fileContent = `
// This file is auto-generated by maintenance/generateCCExports.ts
// Do not edit it by hand or your changes will be lost!

`;

function compareStrings(a: string, b: string): number {
	if (a > b) return 1;
	if (b > a) return -1;
	return 0;
}

// Generate type and value exports for all found symbols
for (const [filename, fileExports] of [
	...findExports().entries(),
].sort(([fileA], [fileB]) => compareStrings(fileA, fileB))) {
	const relativePath = path
		.relative(ccIndexFile, filename)
		// normalize to slashes
		.replace(/\\/g, "/")
		// TS imports may not end with ".ts"
		.replace(/\.ts$/, "")
		// By passing the index file as "from", we get an erraneous "../" at the path start
		.replace(/^\.\.\//, "./");
	const typeExports = fileExports.filter((e) => e.typeOnly);
	if (typeExports.length) {
		fileContent += `export type { ${typeExports
			.map((e) => e.name)
			.join(", ")} } from "${relativePath}"\n`;
	}
	const valueExports = fileExports.filter((e) => !e.typeOnly);
	if (valueExports.length) {
		fileContent += `export { ${valueExports
			.map((e) => e.name)
			.join(", ")} } from "${relativePath}"\n`;
	}
}

// Make the linter happy
export function formatWithPrettier(sourceText: string): string {
	// Keep this in sync with templates/_prettierrc.js.ts
	const prettierOptions = {
		...require("../.prettierrc"),
		// To infer the correct parser
		filepath: ccIndexFile,
	};
	return prettier.format(sourceText, prettierOptions);
}

// And write the file
fs.writeFileSync(ccIndexFile, formatWithPrettier(fileContent), "utf8");
process.exit(0);
